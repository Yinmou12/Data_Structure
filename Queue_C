#ifndef __STATEMENT_H__
#define __STATEMENT_H__


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#define TRUE 1
#define FALSE 0
#define OVERFLOW -2
#define INFEASIBLE -1
#define OK 1
#define ERROR -1

// ***************** 顺序队列 *****************
#define MAXQSIZE 6      //最大队列长度
typedef int QElemType;
typedef struct SqQueue
{
    QElemType *base;
    int front;      
    int rear;   
}SqQueue;
// 初始化
int InitSqQueue(SqQueue *Q);
// 求队列长度
int GetSqQueueLength(SqQueue Q);
// 入队
int EnSqQueue(SqQueue *Q,QElemType e);
// 出队
int DeSqQueue(SqQueue *Q,QElemType *e); 
// 取队头元素
QElemType GetHeadElem(SqQueue Q);



// ***************** 链式队列 *****************
typedef struct QNode
{
    QElemType data;
    struct QNode *next;
}QNode;
typedef struct LinkQueue
{
    QNode *front;
    QNode *rear;
}LinkQueue;
// 初始化
int InitLinkQueue(LinkQueue *Q);
// 求队列长度
int GetLinkQueueLength(LinkQueue Q);
// 入队
int EnLinkQueue(LinkQueue *Q,QElemType e);
// 出队
int DeLinkQueue(LinkQueue *Q,QElemType *e);
// 取队头元素
QElemType GetLQHeadELem(LinkQueue Q);
// 销毁
int DestroyLinkQueue(LinkQueue *Q);


#endif

// ---------------------------------------------------- queue.c ----------------------------------------------------
#include "./header/statement.h"

// ***************** 顺序队列 *****************
// 初始化
int InitSqQueue(SqQueue *Q)
{
    Q->base = (QElemType *)malloc(sizeof(QElemType) * MAXQSIZE);
    if( !(Q->base) )
    {
        printf("%s\n",strerror(errno));
        return ERROR;
    }
    Q->front = 0;
    Q->rear = 0;
    return OK;
}
// 求队列长度
int GetSqQueueLength(SqQueue Q)
{
    return (( Q.rear + MAXQSIZE - Q.front ) % MAXQSIZE);
}
// 入队
int EnSqQueue(SqQueue *Q,QElemType e)
{
    if( (Q->rear + 1) % MAXQSIZE == Q->front)
    {
        printf("队列已满!\n");
        return ERROR;
    }
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXQSIZE;
    return OK;
}
// 出队
int DeSqQueue(SqQueue *Q,QElemType *e)
{
    if( Q->front == Q->rear )
    {
        printf("队列为空!\n");
        return ERROR;
    }
    *e = Q->base[Q->front];
    Q->front = (Q->front + 1) % MAXQSIZE;
    return OK;
}
// 取队头元素
QElemType GetHeadElem(SqQueue Q)
{
    if(Q.rear != Q.front)
        return Q.base[Q.front];
}



// ***************** 链式队列 *****************
// 初始化
int InitLinkQueue(LinkQueue *Q)
{
    Q->front = (QNode *)malloc(sizeof(QNode));
    Q->rear = (QNode *)malloc(sizeof(QNode));
    if( !(Q->front) || !(Q->rear))
    {
        printf("%s\n",strerror(errno));
        return ERROR;
    }
    Q->front->next = NULL;
    Q->rear = Q->front;
    return OK;
}
// 求队列长度
int GetLinkQueueLength(LinkQueue Q)
{
    return (Q.rear - Q.front);
}
// 入队
int EnLinkQueue(LinkQueue *Q,QElemType e)
{
    QNode *p = (QNode *)malloc(sizeof(QNode));
    if(!p)
    {
        printf("%s\n",strerror(errno));
        return ERROR;
    }
    p->data = e;
    p->next = NULL;
    Q->rear->next = p;
    Q->rear = p;
    return OK;
}
// 出队
int DeLinkQueue(LinkQueue *Q,QElemType *e)
{
    if(Q->front->next == NULL)
    {
        printf("队列为空!\n");
        return ERROR;
    }
    QNode *p = (QNode *)malloc(sizeof(QNode));
    p = Q->front->next;
    *e = p->data;
    Q->front->next = p->next;
    free(p);
    p = NULL;
    return OK;
}// 00 30
// 取队头元素
QElemType GetLQHeadELem(LinkQueue Q)
{
    if(Q.front != Q.rear)
        return Q.front->data;
}
// 销毁
int DestroyLinkQueue(LinkQueue *Q)
{
    QNode *p = (QNode *)malloc(sizeof(QNode));
    p = Q->front;
    while(p)
    {
        Q->front = Q->front->next;
        free(p);
        p = Q->front;
    }
    return OK;
}



// ---------------------------------------------------- main.c ----------------------------------------------------
#include "./header/statement.h"


// ***************** 顺序队列 *****************
// int main()
// {
//     SqQueue Q;
//     InitSqQueue(&Q);
//     EnSqQueue(&Q,10);
//     EnSqQueue(&Q,20);
//     EnSqQueue(&Q,30);
//     EnSqQueue(&Q,40);
//     EnSqQueue(&Q,50);
//     EnSqQueue(&Q,60);
//     QElemType headELem;
//     QElemType ret;
//     headELem = GetHeadElem(Q);
//     printf("headELem = %d\n",headELem);
//     DeSqQueue(&Q,&ret);
//     printf("ret = %d\n",ret);
//     DeSqQueue(&Q,&ret);
//     printf("ret = %d\n",ret);
//     DeSqQueue(&Q,&ret);
//     headELem = GetHeadElem(Q);
//     printf("headELem = %d\n",headELem);
//     printf("ret = %d\n",ret);
//     DeSqQueue(&Q,&ret);
//     printf("ret = %d\n",ret);
//     DeSqQueue(&Q,&ret);
//     printf("ret = %d\n",ret);
//     DeSqQueue(&Q,&ret);
//     return 0;
// }



// ***************** 链式队列 *****************
// int main()
// {
//     LinkQueue Q;
//     InitLinkQueue(&Q);
//     printf("队列长度:%d\n",GetLinkQueueLength(Q));
//     EnLinkQueue(&Q,10);
//     EnLinkQueue(&Q,20);
//     EnLinkQueue(&Q,30);
//     printf("队列长度:%d\n",GetLinkQueueLength(Q));
//     QElemType headELem;
//     headELem = GetLQHeadELem(Q);
//     QElemType ret;
//     printf("ret = %d\n",ret);
//     DeLinkQueue(&Q,&ret);
//     printf("ret = %d\n",ret);
//     DeLinkQueue(&Q,&ret);
//     printf("ret = %d\n",ret);
//     DeLinkQueue(&Q,&ret);
//     printf("ret = %d\n",ret);
//     DeLinkQueue(&Q,&ret);
//     return 0;
// }

